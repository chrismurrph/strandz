/*
    Strandz - an API that matches the user to the data.
    Copyright (C) 2007 Chris Murphy

    Strandz is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    Strandz is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Strandz; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    In addition, as a special exception, Chris Murphy gives
    permission to link the code of this program with any Java software for
    which complete source code is available at no cost (even if distribution
    or modification of that source code is restricted), and distribute the
    results of that linking. You must obey the GNU General Public
    License in all respects for all of the code used other than this Java code.
    If you modify this file, you may extend this exception to your version of
    the file, but you are not obligated to do so. If you do not wish to do so,
    delete this exception statement from your version.

    The authors can be contacted via www.strandz.org
*/
package org.strandz.core.applichousing;

import org.strandz.core.interf.Node;
import org.strandz.core.interf.NodeController;
import org.strandz.core.interf.SdzBagI;
import org.strandz.core.interf.VisibleStrandAction;
import org.strandz.core.interf.VisibleStrandHelper;
import org.strandz.core.interf.VisibleStrandI;
import org.strandz.core.interf.RelocationBackCallbacksI;
import org.strandz.core.interf.RelocationOutCallbacksI;
import org.strandz.core.interf.Application;
import org.strandz.lgpl.note.SdzNote;
import org.strandz.lgpl.store.DataStore;
import org.strandz.lgpl.util.Assert;
import org.strandz.lgpl.util.Err;
import org.strandz.view.util.AbstractStrandArea;

import javax.swing.JComponent;
import java.awt.event.ActionEvent;

/**
 * Instances of <code>VisibleStrand</code>s are the RT core of any Strandz
 * 'application housed' Application. The term 'actionable' means that subclasses
 * the capable of being controlled by an Application. This means initialised,
 * displayed, undisplayed etc - see the interface this abstract class implements:
 * <code>ActionableStrandI</code> for specifics.
 * <p/>
 * The actual <code>Strand</code> is accessible from here, but we are now at RT and there is
 * alot more going on. We keep the name Strand as this is essentially still a
 * group of nodes.
 * <p/>
 * The most important function of these subclasses is to get hold of the DT
 * information and to do something sensible like execute a query. The DT
 * information gives type safe access to a <code>SdzBagI</code>, which basically
 * gives you the structure of your application. The <code>SdzBagI</code> will usually be 
 * a <code>SdzBag</code>.
 * <p/>
 * When generated by SdzDsgnr this code is expected to be very stable. By this I
 * mean that you will probably only need to generate it once, and you will probably
 * never need to alter it.
 *
 * @author Chris Murphy
 */
abstract public class VisibleStrand
        implements VisibleStrandI
{
    private Application application;
    private VisibleStrandHelper visibleStrandHelper;
    private AbstractStrandArea strandArea;
    public boolean firstTime = true;
    private DataStore data; // unit test
    private boolean adorned = true;
    protected SdzBagI sbI;
    private String title;
    private RelocationMemento relocationMemento;

    //Old message:
    //"Not being part of an application s/be becoming impossible"
    /**
     * ProdKpiStartup does an init() and has its own:
     * ProdKpiHousing
     * ProdKpiVisibleStrandHelper
     * - and does fine without an application
     */
    public static String NEED_APPLICATION_MSG =
        "See ProdKpiStartup for how to run a VisibleStrand without an application";

    protected VisibleStrand()
    {
    }
    
    public VisibleStrand(Application application)
    {
        this.application = application;
    }

    public void initSdzBag(boolean partOfApplication)
    {
        Assert.notNull( this.sbI);
        initSdzBag( this.sbI, partOfApplication);
    }
        
    public void initSdzBag(SdzBagI sbI)
    {
        initSdzBag( sbI, true);
    }
    
    public void initSdzBag(SdzBagI sbI, boolean partOfApplication)
    {
        if(sbI instanceof SdzBag)
        {
            ((SdzBag)sbI).setPartOfApplication( partOfApplication);
            ((SdzBag)sbI).getBarHelper().setStrandArea( strandArea);
        }
        else if(sbI instanceof UnadornedSdzBag)
        {
            ((UnadornedSdzBag)sbI).setPartOfApplication( partOfApplication);
            adorned = false;
        }
        else
        {
            Err.error( getClass().getName() + " does not support " + sbI.getClass());
        }
        if(application != null)
        {
            if(partOfApplication)
            {
                visibleStrandHelper = application.createStrandHelper( sbI, this,
                                                                      (AbstractStrandArea.EnclosurePanel)application.getEnclosure( this));
            }
            else
            {
                visibleStrandHelper = application.createStrandHelper( sbI, this,
                                                                      (AbstractStrandArea.EnclosurePanel)strandArea.getEnclosure());
            }
        }
        this.sbI = sbI;
        Err.pr( SdzNote.NO_HOUSING_HELPERS, 
                "initSdzBag happening too late, adorned set to " + adorned + " for " + this.getClass().getName());
    }

    public SdzBagI getSdzBagI()
    {
        return sbI;
    }

    public void setSbI( SdzBagI sbI)
    {
        this.sbI = sbI;
    }


    /**
     * Relocate from being inside an application to being outside of the application
     * in a different AbstractStrandArea. Call relocateBack() to return this to its
     * usual place. 
     *  
     * @param newLocation
     * @param relocationOutCallbacks
     * @return
     */
    public void relocateOut( AbstractStrandArea newLocation, 
                             RelocationOutCallbacksI relocationOutCallbacks,
                             VisibleStrandI callingStrand)
    {
        relocationMemento = new RelocationMemento();
        Err.pr( SdzNote.VISIBLE_STRAND_IS_INDEPENDENT, "sbI used to be " + getSdzBagI().getClass().getName());
        if(getApplication().isDisplayed( this))
        {
            relocationMemento.previouslyDisplayed = true;
        }
        relocationMemento.applicationStrandArea = getStrandArea(); //Will need to put the transferStrand back to original
                                                                   // condition
        relocationMemento.callingStrand = callingStrand;
        relocationMemento.position = getApplication().getPosition( this); 
        //Physically remove the 'tab' from the application whilst still have knowledge of the tabs
        getApplication().removeVisibleStrand( this, "Removing VisibleStrand from Application b/c relocating out");
        setStrandArea( newLocation);
        //Uses the existing sdzI and allows the transferStrand helpers to pick up on the changed strandArea:
        initSdzBag( false);
        relocationOutCallbacks.performAlterSdzSetup();
        relocationOutCallbacks.setPanelNodeTitles();
        relocationOutCallbacks.display();
        attachControls();
    }
    
    public void relocateBack( RelocationBackCallbacksI relocationBackCallbacks)
    {
        Err.pr( SdzNote.TRANSFER_OUT_POSITION, "Just put on end rather than at position " + relocationMemento.position);
        relocationBackCallbacks.performAlterSdzSetup();
        setStrandArea( relocationMemento.applicationStrandArea);
        initSdzBag( true);
        relocationBackCallbacks.setPanelNodeTitles();
        if(relocationMemento.previouslyDisplayed)
        {
            getApplication().changeActionableStrand( this, "Was previously displayed so going back to it temporarily");
            relocationMemento.callingStrand.getApplication().changeActionableStrand( 
                    relocationMemento.callingStrand, "Going back to calling strand");
        }
        Node nodeSinceDialog = relocationMemento.callingStrand.getSdzBagI().getStrand().getCurrentNode();
        Err.pr( SdzNote.SET_ROW, "When come back from dialog current node is " + nodeSinceDialog);
        Err.pr( SdzNote.SET_ROW, "So after user dismissed, row is " + nodeSinceDialog.getRow());
    }
    
    public static class RelocationMemento
    {
        /**
         * The usual or old StrandArea that houses the visibleStrand we are going to
         * grab and alter for other purposes (for example displaying in a Dialog).
         * Because we will later need to put the visibleStrand back into here we save it.
         */
        public AbstractStrandArea applicationStrandArea;
        /**
         * Whether the actor was previously displayed. As a matter of course we un-display it
         * while the new form of display is the current form. This indicates that after the
         * current form is complete we must re-display it in the old form.
         */
        public boolean previouslyDisplayed = false;
        /**
         * Currently displayed VisibleStrand that we may want to go back to if we need
         * to redisplay the actor. 
         */
        public VisibleStrandI callingStrand;
        /**
         * The position that the visible strand was within the application
         */
        public int position;
    }

    public boolean isAdorned()
    {
        Err.pr( SdzNote.NO_HOUSING_HELPERS, "Returning adorned " + adorned + " in " + this.getClass().getName());
        return adorned;
    }

    public void setAdorned(boolean adorned)
    {
        this.adorned = adorned;
    }

    public Application getApplication()
    {
        return application;
    }

    public void setPanelNodeTitle(JComponent panel, Node node, String tabName)
    {
        visibleStrandHelper.setPanelNodeTitle(panel, node, tabName);
    }

    public void setNodeController(NodeController nc)
    {
        visibleStrandHelper.setNodeController(nc);
    }

    public NodeController getNodeController()
    {
        Assert.notNull(visibleStrandHelper, "initSdzBag has not been called on " + this);
        return visibleStrandHelper.getNodeController();
    }
    
    public void detachControls()
    {
        visibleStrandHelper.setRequiresRefresh();
        visibleStrandHelper.detachControls( true);
        //Was causing node to change:
        //setCurrentPane( 0);
    }
    
    public void attachControls()
    {
        visibleStrandHelper.detachControls( false);
    }
    
    public void display( boolean b)
    {
        if(b)
        {
            /*
             * When R-click close was done we detached the controls. Thus just in case we
             * are re-displaying after a detachment we attach all the controls to make
             * sure they are attached.
             */
            Err.pr( SdzNote.BRING_BACK_TAB, "Making up for earlier detachment when R-click closed");
            attachControls();
        }
        visibleStrandHelper.display(b);
    }

    abstract public boolean select( boolean b, String reason);

    public void setCurrentPane( int idx)
    {
        visibleStrandHelper.setCurrentPane(idx);
    }

    public void setStrandArea( AbstractStrandArea belowMenuPanel)
    {
        strandArea = belowMenuPanel;
    }

    public AbstractStrandArea getStrandArea()
    {
        return strandArea;
    }

    class VisibleStrandActionListener implements java.awt.event.ActionListener
    {
        public void actionPerformed(ActionEvent e)
        {
            // When tried to do another way (like postForm()),
            // controller did not get activated. Thus think b4
            // trying to change again! RUBBISH - do later and worked!
            Err.error("S/be done in Application now");

            VisibleStrandAction source = (VisibleStrandAction) e.getSource();
            if(source.getVisibleStrand() == VisibleStrand.this)
            {
                if(firstTime)
                {
                    preForm();
                    firstTime = false;
                }
            }
            else
            {
                Err.error("Impossible if listening to VisibleStrandAction");
            }
        }
    }

    public void setApplication(Application application)
    {
        this.application = application;
    }

    public DataStore getDataStore()
    {
        return data;
    }

    public void setDataStore(DataStore data)
    {
        if(data != null)
        {
            if(this.data != null && data != this.data)
            {
                Err.error("Should never be setting data to another data");
            }
        }
        this.data = data;
    }

    public String getTitle()
    {
        return title;
    }

    public void setTitle(String title)
    {
        this.title = title;
    }

    public SdzBagI getSbI()
    {
        return sbI;
    }

    public void setVisibleStrandHelper(VisibleStrandHelper visibleStrandHelper)
    {
        this.visibleStrandHelper = visibleStrandHelper;
    }
}
