/*
    Strandz LGPL - an API that matches the user to the data.
    Copyright (C) 2007 Chris Murphy

    Strandz LGPL is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


    The authors can be contacted via www.strandz.org
*/
package org.strandz.lgpl.util;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

/**
 * This class was originally used to create makefiles before ant came along.
 * Will still be useful for managing all the files in a particular directory.
 *
 * @author Chris Murphy
 */
class JavaPackage
{
    private static final String EXTENSION = "java";
    private static final String NEW_EXTENSION = "class";
    private static final String MAKEFILE_NAME = "makefile.mk";
    // private String extension = EXTENSION;

    private String fullPath;
    private ArrayList fileNames = new ArrayList();

    /**
     * Constructs a JavaPackage with the default extension. (We are defining
     * a package as being made up of a path and the extension type of the files
     * directly underneath it).
     *
     * @param fullPath The path to the root directory
     */
    public JavaPackage(String fullPath)
    {
        this(fullPath, EXTENSION);
    }

    /**
     * Constructs a JavaPackage. (We are defining
     * a package as being made up of a path and the extension type of the files
     * directly underneath it).
     *
     * @param fullPath  The path to the root directory
     * @param extension The kind of files that make up our package. Usually either
     *                  .java or .class
     */
    public JavaPackage(String fullPath, String extension)
    {
        this.fullPath = fullPath;

        // Err.pr( fullPath);
        File file = new File(fullPath);
        String[] list = file.list();
        if(list != null)
        {
            for(int i = 0; i <= list.length - 1; i++)
            {
                File innerFile = new File(fullPath + FileUtils.FILE_SEPARATOR + list[i]);
                if(innerFile.isFile())
                {
                    if(NameUtils.hasOneExtension(innerFile))
                    {
                        if(NameUtils.endsIn(extension, innerFile.getName()))
                        {
                            fileNames.add(innerFile.getName());
                            // Err.pr( "\t" + innerFile.getName());
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns the output of constructing a JavaPackage.
     *
     * @return A list of all the file names in this package
     */
    List getFileNames()
    {
        return fileNames;
    }

    /**
     * JAVAC=sj
     * <p/>
     * CLASSFILES= \
     * C:\temp\java\packages\mmi\eclaims\ECL_IndexedDataStream.class \
     * C:\temp\java\packages\mmi\eclaims\EClaimFrame.class
     * <p/>
     * all: $(CLASSFILES)
     * <p/>
     * .SUFFIXES: .java .class
     * <p/>
     * {C:\temp\java\packages\mmi\eclaims}.java{C:\temp\java\packages\mmi\eclaims}.class :
     * #       set CLASSPATH=%CLASSPATH%
     * $(JAVAC) -classpath $(CLASSPATH) $<
     * <p/>
     * clean:
     * -del C:\temp\java\packages\mmi\eclaims\*.class
     */
    void writeMakeFile()
    {
        PrintWriter out = null;
        try
        {
            out = new PrintWriter(
                new FileWriter(fullPath + FileUtils.FILE_SEPARATOR + MAKEFILE_NAME));
        }
        catch(IOException ex)
        {
            throw new Error("ERROR " + ex);
        }
        out.println("#");
        out.println("# generated by Chris Murphy: " + new Date());
        out.println("#");
        out.println("");
        // out.println( "JAVAC=C:\\jdk1.2\\bin\\javac -g");
        out.println("JAVAC=javac -g");
        out.println("");
        out.println("CLASSFILES= \\");
        for(Iterator en = fileNames.iterator(); ;)
        {
            Print.print("\t");

            String fileName = (String) en.next();
            Print.print(
                fullPath + FileUtils.FILE_SEPARATOR
                    + NameUtils.giveNewExtension(fileName, NEW_EXTENSION));
            if(en.hasNext())
            {
                out.println(" \\");
            }
            else
            {
                break;
            }
        }
        out.println("");
        out.println("all: $(CLASSFILES)");
        out.println("");
        out.println(".SUFFIXES: ." + EXTENSION + " ." + NEW_EXTENSION);
        out.println("");
        out.println(
            "{" + fullPath + "}." + EXTENSION + "{" + fullPath + "}."
                + NEW_EXTENSION + ":");
        out.println("\t" + "set CLASSPATH=%CLASSPATH%");
        out.println("\t" + "$(JAVAC) -classpath $(CLASSPATH) $<");
        // out.println( "");
        // out.println( "clean:");
        // out.println("\t -del " + fullPath + "\\." + NEW_EXTENSION);
        out.close();
    }

    String getMakeFilePath()
    {
        return fullPath + FileUtils.FILE_SEPARATOR + MAKEFILE_NAME;
  }
}
